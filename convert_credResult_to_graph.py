#!/usr/bin/python
#
# This script converts CRED graphs into other kind of graphs using the igraph-python library. The format of the input
# CRED graph must be a JSON file generated by the cli2 command. This file follows the credResult.js type definition:
# https://github.com/sourcecred/sourcecred/blob/2fd32dd78547a101c33d2c0112962b8b9f2503fb/src/analysis/credResult.js#L30-L42
#
# Note that CRED graphs support dangling edges (i.e., edges with no source/target nodes). Dangling edges are not
# included in the resulting converted graph (a message notifies the number of dangling edges found)
#
# Author: Javier Canovas (me@jlcanovas.es)
#

import getopt
import json
import sys

from igraph import Graph

"""
Usage of this script
Main options:
-i   - The path of the CRED graph (credResult.json file)
-o   - The path for the generated graph
-f   - Format of the generated graph (gml, graphml, dot, svg...)
"""
USAGE = 'convert_credResult_to_graph.py -i CRED_GRAPH_PATH -o OUTPUT_GRAPH -f OUTPUT_GRAPH_FORMAT'


def convert_graph(input_path):
    """
    Converts a CRED-like graph into a graph format supported by the igraph library. The input graph must have been
    generated by cli2 CRED command (look for credResult.json)
    :param input_path: The path to the CRED graph to convert (credResult.json)
    """

    with open(input_path, encoding="utf8") as f:
        cred_file = json.load(f)

    # Locating important elements in the graph
    cred_data = cred_file[1]['credData']
    graph = cred_file[1]['weightedGraph'][1]['graphJSON'][1]
    cred_node_addresses = graph['sortedNodeAddresses']

    # Summary of edges/nodes and also a reminder about dangling edges
    print(f'Found cred summary data for {len(cred_data["nodeSummaries"])} nodes and {len(cred_data["edgeSummaries"])} edges')
    print(f'The graph has {len(graph["nodes"])} nodes, {len(graph["edges"])} edges and {len(graph["sortedNodeAddresses"])} node addresses')
    print(f'Dangling edges expected: {len(graph["edges"]) - len(cred_data["edgeSummaries"])}')

    g = Graph(directed=True)

    # Collecting nodes
    for i, cred_node in enumerate(graph['nodes']):
        cred_node_address = cred_node_addresses[cred_node['index']]
        igraph_node_atts = {'label': cred_node_address[2]+'-'+cred_node_address[-1][:7],
                            'type': cred_node_address[2],
                            'timestamp': cred_node['timestampMs'] if cred_node['timestampMs'] is not None else 0,
                            'totalCred': cred_data['nodeSummaries'][i]['cred'],
                            'index': cred_node['index'],
                            }
        g.add_vertex(name=str(cred_node['index']), **igraph_node_atts)

    # Collecting edges
    dangling_edges = []
    idx = 0
    for cred_edge in graph['edges']:
        # Checking if the edges is a dangling one. If so, we skip.
        if len(g.vs.select(name_eq=str(cred_edge['srcIndex']))) + len(g.vs.select(name_eq=str(cred_edge['dstIndex']))) < 2:
            dangling_edges.append({"srcIndex": cred_edge['srcIndex'], "dstIndex": cred_edge['dstIndex']})
            continue

        igraph_edge_atts = {'address': '-'.join(cred_edge['address']),
                            'timestamp': cred_edge['timestampMs'],
                            'backwardFlow': cred_data['edgeSummaries'][idx]['backwardFlow'],
                            'forwardFlow': cred_data['edgeSummaries'][idx]['forwardFlow'],
                            }
        g.add_edge(str(cred_edge['srcIndex']), str(cred_edge['dstIndex']), **igraph_edge_atts)
        idx += 1

    # Reporting the number of dangling edges found
    print(f"Dangling edges found: {len(dangling_edges)}")

    return g


def main(argv):
    if len(argv) == 0:
        sys.exit(0)

    try:
        opts, args = getopt.getopt(argv, "hi:o:f:", [])
    except getopt.GetoptError:
        print(USAGE)
        sys.exit(2)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print(USAGE)
            sys.exit()
        elif opt in ('-i'):
            input_path = arg
        elif opt in ('-o'):
            output_path = arg
        elif opt in ('-f'):
            output_format = arg

    g = convert_graph(input_path)
    Graph.save(g, output_path, format=output_format)


if __name__ == "__main__":
    main(sys.argv[1:])
