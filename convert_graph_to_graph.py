#!/usr/bin/python
#
# This script converts graphs created by sourcecred into other kind of graphs using the igraph-python library.
# The format of the input graph must be a JSON file generated by sourcecred (normally stored in output folder).
#
# Note that CRED graphs support dangling edges (i.e., edges with no source/target nodes). Dangling edges are not
# included in the resulting converted graph (a message notifies the number of dangling edges found)
#
# Author: Javier Canovas (me@jlcanovas.es)
#

import getopt
import json
import sys

from igraph import Graph

"""
Usage of this script
Main options:
-i   - The path of the graph (graph.json file)
-o   - The path for the generated graph
-f   - Format of the generated graph (gml, graphml, dot, svg...)
"""
USAGE = 'convert_graph_to_graph.py -i CRED_GRAPH_PATH -o OUTPUT_GRAPH -f OUTPUT_GRAPH_FORMAT'

def extract_node_name(node_address):
    """Given a graph node address, returns the label. For the sake of clarity, COMMENT node addresses return empty.
    :param node_address: The node address
    :return: The label
    """
    node_type = node_address[2]
    if node_type == "COMMIT":
        return node_address[3][-7:]
    elif node_type == "REPO":
        return node_address[3] + '/' + node_address[4]
    elif node_type == "USERLIKE":
        return node_address[4]
    elif node_type == "ISSUE":
        return node_address[5]
    elif node_type == "REPO":
        return node_address[5]
    elif node_type == "COMMENT":
        return ""

def extract_edge_type(edge_address):
    """Given a graph edge address, returns the edge type.
    :param edge_address: The edge address
    :return: The label
    """
    edge_type = edge_address[2]
    if edge_type == "REACTS":
        return "REACTS" + edge_address[3]
    else:
        return edge_type

def convert_graph(input_path):
    """
    Converts a graph generated by sourcecred into a graph format supported by the igraph library.
    :param input_path: The path to the CRED graph to convert (graph.json)
    """

    with open(input_path, encoding="utf8") as f:
        cred_file = json.load(f)

    # Locating important elements in the graph
    graph = cred_file[1]['graphJSON'][1]
    sc_node_addresses = graph['sortedNodeAddresses']

    # Summary of edges/nodes and also a reminder about dangling edges
    print(f'The graph has {len(graph["nodes"])} nodes, {len(graph["edges"])} edges and {len(graph["sortedNodeAddresses"])} node addresses')

    g = Graph(directed=True)

    # Collecting nodes
    for i, sc_node in enumerate(graph['nodes']):
        sc_node_address = sc_node_addresses[sc_node['index']]
        igraph_node_atts = {'label': extract_node_name(sc_node_address),
                            'type': sc_node_address[2],
                            'timestamp': sc_node['timestampMs'] if sc_node['timestampMs'] is not None else 0,
                            'index': sc_node['index'],
                            }
        g.add_vertex(name=str(sc_node['index']), **igraph_node_atts)

    # Collecting edges
    dangling_edges = []
    idx = 0
    for sc_edge in graph['edges']:
        # Checking if the edges is a dangling one. If so, we skip.
        if len(g.vs.select(name_eq=str(sc_edge['srcIndex']))) + len(g.vs.select(name_eq=str(sc_edge['dstIndex']))) < 2:
            dangling_edges.append({"srcIndex": sc_edge['srcIndex'], "dstIndex": sc_edge['dstIndex']})
            continue

        igraph_edge_atts = {'address': '-'.join(sc_edge['address']),
                            'timestamp': sc_edge['timestampMs'],
                            'type': extract_edge_type(sc_edge['address'])
                            }
        g.add_edge(str(sc_edge['srcIndex']), str(sc_edge['dstIndex']), **igraph_edge_atts)
        idx += 1

    # Reporting the number of dangling edges found
    print(f"Dangling edges found: {len(dangling_edges)}")

    return g


def main(argv):
    if len(argv) == 0:
        sys.exit(0)

    try:
        opts, args = getopt.getopt(argv, "hi:o:f:", [])
    except getopt.GetoptError:
        print(USAGE)
        sys.exit(2)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print(USAGE)
            sys.exit()
        elif opt in ('-i'):
            input_path = arg
        elif opt in ('-o'):
            output_path = arg
        elif opt in ('-f'):
            output_format = arg

    g = convert_graph(input_path)
    Graph.save(g, output_path, format=output_format)


if __name__ == "__main__":
    main(sys.argv[1:])
